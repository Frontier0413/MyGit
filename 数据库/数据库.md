# MYSQL数据库

## 事务的隔离级别

1. 未提交读。指的是事务中的查询语句能够看到其他事务未提交的结果，这种情况可能可能导致脏读，即某事务中读取了其他事务尚未提交的写操作。但该写操作的事务未能完成，因此，所读出来的数据实际是不存在的，即脏数据。

2. 提交读(不可重复度)。大多数数据库系统的默认级别都是不可重复读（MYSQL不是）。该隔离级别下，所有事物在未提交时对其他事务是不可见的。也就是说，一个事务开始时，只能看见已经提交的事务所做的更改。这个级别也叫不可重复读，因为同一个事务中的不同的读结果可能是不同的。该级别下不会出现脏读，但会出现幻读与不可重复读。

3. 可重复读。可重复读解决了脏读的问题，但是理论上还有另外一个幻读的问题：即一个事务在读某个范围内的数据时，其他事务在这个范围内插入了数据。当事务再次读取该范围内的记录时，机会出现幻行。该级别下不会出现脏读与不可重复读。

4. 可串行化。该级别可以解决脏读，不可重复读与幻读的问题，但是效率过低，一般很少使用。

## 事务的ACID

1. 原子性。指事务是不可再分的，即一个事务的操作，要么全部完成，要么全部不完成。如果事务在执行过程中出错，会被回滚到事务开始之前的状态，就像这个事务没有执行过一样。

2. 一致性。一个事务可以改变状态。事务必须始终保持系统处于一致的状态，不管并发事务有多少。即事务前后数据的完整性必须一致。

3. 隔离性。隔离状态执行事务，好像他们是在系统给定的时间内唯一执行的事务一样。数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰。隔离隐藏一般通过悲观锁或乐观锁实现。

4. 持久性。指一个事务一旦被提交，他对数据库中数据的改变就是永久性的，机械来即使数据库发生故障也不能对其有影响。一个事务所做的更在在提交后会被记录在持久的事务日志中。

## 数据库引擎InnoDB与MyISAM

1. InnoDB支持事务而MyISAM不支持。对于InnoDB的每一条语句都默认封装成事务，因此会影响效率，正确的做法是在多条语句前后加上BEGIN TRANSACTION和COMMIT

2. 两种数据库引擎索引都是用B+树。

3. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB的表转成MyISAM会失败。

4. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，即先查询到主键，然后再通过主键查询到数据。因此，主键不应该太大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，索引保存的数据文件的指针，主键索引和辅助索引是独立的。

5. InnoDB不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM更高。

6. InnoDB不保存具体的行数，使用SELECT *时需要扫描全表。而MyISAM用一个变量保存表的行数。

7. MyISAM系统崩溃后，恢复起来很困难。

## MYSQL中的锁机制

1. 表级锁。表级锁开销小，加锁快，不会出现死锁，锁粒度大，发生锁冲突的概率很高，并发度很低。

2. 行级锁。锁开销大，加锁慢，会出现死锁，锁粒度最小，发生锁冲突的概率很小，并发度很高。

3. 页面锁。 开销和加锁时间介于表级锁和行级锁之间，会出现死锁，锁粒度与并发度也处于表级锁与行级锁之间。

4. 表级锁有两种模式，即表共享读锁与表独占写锁。查询操作所在的线程会获得一个共享锁，获得共享锁的线程不会阻塞其他获得共享锁的线程，但会阻塞获得独占锁的线程。获得独占锁的线程会阻塞其他任意获得共享锁与独占锁的线程。在MyISAN中，写锁具有更高的优先级，即在锁等待队列中，写锁会直接插到读锁的前面。

5. 行级锁分为共享锁（读锁）与排他锁（写锁）。共享锁允许一个事务去读一行，并组织其他事务获得改行的排他锁。其他事务只能再对改行加共享锁，而不能加排他锁。允许获得排他锁的事务修改与查询数据，不允许其他事务获得该行的共享锁或排他锁。在InnoDB中，select语句本身是不加锁的。也就是说，select仍然可以查询加了排他锁的数据。

6. InnoDB是通过索引来对数据加行锁的。也就是说，只有通过索引条件执行语句，才会加行锁，否则InnoDB会加表锁。

7. 间隙锁。当我们使用范围条件来检索数据时，InnoDB会给符合条件的数据加锁，但对于键值在条件范围内但不存在的记录，也会加锁，这种不存在的记录叫做间隙，这种锁叫做间隙锁。

8. 悲观锁与乐观锁。InnoDB默认是悲观锁，即共享锁与排他锁。
